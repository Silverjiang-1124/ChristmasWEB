<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Merry Christmas - Particle Tree</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#050617;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif}
    #canvas-container{position:fixed;inset:0;z-index:1}
    #video-input{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none}

    /* loader */
    #loader{
      position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
      z-index:999;background:radial-gradient(1200px 800px at 50% 45%, rgba(255,223,0,0.08), rgba(0,0,0,0));
      backdrop-filter:blur(16px);
      color:#ffdf00;letter-spacing:2px;
    }
    .spinner{
      width:52px;height:52px;border-radius:50%;
      border:3px solid rgba(255,223,0,0.25);
      border-top-color:rgba(255,223,0,0.95);
      animation:spin 1s linear infinite;
      box-shadow:0 0 28px rgba(255,223,0,0.18);
    }
    @keyframes spin{to{transform:rotate(360deg)}}

    /* UI */
    #ui{
      position:fixed;left:50%;top:24px;transform:translateX(-50%);
      z-index:20;pointer-events:none;text-align:center;
      padding:14px 18px;border-radius:18px;
      background:rgba(8,10,26,0.35);
      border:1px solid rgba(255,223,0,0.18);
      box-shadow:0 18px 60px rgba(0,0,0,0.35);
      backdrop-filter:blur(12px);
      max-width:min(760px, calc(100vw - 24px));
    }
    #title{
      font-family:ui-serif, "Times New Roman", Times, serif;
      letter-spacing:10px;font-size:44px;margin:0;
      color:rgba(255,241,200,0.92);
      text-shadow:0 0 28px rgba(255,223,0,0.22);
      user-select:none;
    }
    #subtitle{margin-top:10px;letter-spacing:5px;opacity:.85;color:rgba(255,223,0,0.9)}
    #status{margin-top:14px;font-weight:700;color:#ffdf00}

    #controls{
      position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
      z-index:20;
      pointer-events:auto;
      text-align:center;
    }
    .btn{
      border:1px solid rgba(255,223,0,0.55);
      border-radius:30px;
      padding:12px 26px;letter-spacing:2px;
      background:rgba(8,10,26,0.35);
      box-shadow:0 0 18px rgba(255,223,0,0.18);
      backdrop-filter:blur(12px);
      cursor:pointer;user-select:none;
      color:rgba(255,241,200,0.95);
      transition:transform .15s ease, box-shadow .15s ease, background .15s ease;
    }
    .btn:hover{
      transform:translateY(-1px);
      background:rgba(255,223,0,0.12);
      box-shadow:0 0 30px rgba(255,223,0,0.25)
    }
    .btn input{display:none}

    /* 手势预览开关按钮（右下角） */
    #hand-toggle{
      position:fixed;
      right:14px;
      bottom:14px;
      z-index:70;
      padding:8px 16px;
      font-size:12px;
      letter-spacing:1px;
    }

    /* hand preview */
    #hand-panel{
      position:fixed;left:14px;bottom:14px;z-index:60;
      width:260px;border-radius:14px;overflow:hidden;
      border:1px solid rgba(255,223,0,0.35);
      background:rgba(8,10,26,0.35);
      box-shadow:0 0 26px rgba(255,223,0,0.14);
      pointer-events:none;
      backdrop-filter:blur(10px);
    }
    #hand-canvas{width:100%;display:block}
    #hand-debug{
      padding:7px 10px;font-size:12px;letter-spacing:1px;text-align:center;
      color:#ffdf00;border-top:1px solid rgba(255,223,0,0.18)
    }
  </style>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <!-- Three -->
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <div style="margin-top:14px;opacity:.95;color:#ffdf00;letter-spacing:2px">INITIALIZING VISION & MAGIC...</div>
  </div>

  <div id="ui">
    <div id="title">MERRY CHRISTMAS</div>
    <div id="subtitle">梨子，圣诞快乐！</div>
    <div id="status">等待手势识别...</div>
    <div style="margin-top:10px;font-size:12px;color:#bbb;letter-spacing:1px">
      交互：Fist(握拳聚拢) ｜ Open(张开散开/旋转) ｜ Pinch(捏合放大照片)
    </div>
  </div>

  <div id="controls">
    <label class="btn">
      上传照片 (UPLOAD PHOTOS)
      <input type="file" id="upload-input" multiple accept="image/*" />
    </label>
    <div id="manual-controls" style="margin-top:12px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
      <button type="button" class="btn" id="btn-tree"    style="padding:8px 18px;font-size:12px">收起圣诞树 (TREE)</button>
      <button type="button" class="btn" id="btn-scatter" style="padding:8px 18px;font-size:12px">展开圣诞树 (SCATTER)</button>
      <button type="button" class="btn" id="btn-zoom"    style="padding:8px 18px;font-size:12px">展示照片 (ZOOM)</button>
    </div>
  </div>

  <div id="hand-panel">
    <canvas id="hand-canvas" width="260" height="190"></canvas>
    <div id="hand-debug">HAND: --</div>
  </div>

  <button id="hand-toggle" class="btn" type="button">隐藏预览</button>

  <video id="video-input" playsinline muted></video>
  <div id="canvas-container"></div>

<script type="module">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

/* ---------------------------
   CONFIG (toned down to avoid over-exposed tree)
---------------------------- */
const CONFIG = {
  particleCount: 5200,
  glowCount: 1100,
  candyCount: 160,

  treeHeight: 30,
  treeRadius: 14,

  lerpSpeed: 0.06,
  photoLerpZoom: 0.022,
  photoLerpNormal: 0.06,

  /** Key: lower exposure (ACES >1.4 easily blows out) */
  exposure: 0.9,

  /** Key: tighter bloom (lower strength/radius, higher threshold) */
  bloomStrength: 0.45,
  bloomRadius: 0.4,
  bloomThreshold: 0.6,

  turbulenceRadius: 10.0,
  turbulenceStrength: 0.85
};

const ENTIRE_SCENE = 0;
const BLOOM_SCENE = 1;

/* ---------------------------
   THREE CORE
---------------------------- */
const container = document.getElementById("canvas-container");
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050617);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1200);
camera.position.set(0, 12, 50);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = CONFIG.exposure;
container.appendChild(renderer.domElement);

function makeVignetteTexture(){
  const size = 256;
  const cvs = document.createElement("canvas");
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext("2d");
  const grad = ctx.createRadialGradient(size/2, size/2, size*0.26, size/2, size/2, size*0.70);
  // 极轻暗角：只在最外圈略微压暗
  grad.addColorStop(0, "rgba(255,255,255,0.0)");
  grad.addColorStop(1, "rgba(0,0,0,0.25)");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,size,size);
  const tex = new THREE.CanvasTexture(cvs);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.needsUpdate = true;
  return tex;
}
const vignetteTexture = makeVignetteTexture();

/* ---------------------------
   LIGHTING
---------------------------- */
scene.add(new THREE.AmbientLight(0x2a4cff, 0.25));
const keyWarm = new THREE.PointLight(0xffd7a6, 3.0, 260);
keyWarm.position.set(10, 22, 20);
scene.add(keyWarm);

const rim = new THREE.PointLight(0x88a8ff, 1.4, 260);
rim.position.set(-26, 10, -26);
scene.add(rim);

/* ---------------------------
   Selective Bloom
---------------------------- */
const renderScene = new RenderPass(scene, camera);

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(innerWidth, innerHeight),
  CONFIG.bloomStrength,
  CONFIG.bloomRadius,
  CONFIG.bloomThreshold
);

const bloomComposer = new EffectComposer(renderer);
bloomComposer.renderToScreen = false;
bloomComposer.addPass(renderScene);
bloomComposer.addPass(bloomPass);

const finalPass = new ShaderPass(new THREE.ShaderMaterial({
  uniforms: {
    baseTexture: { value: null },
    bloomTexture: { value: bloomComposer.renderTarget2.texture }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
  fragmentShader: `
    uniform sampler2D baseTexture;
    uniform sampler2D bloomTexture;
    varying vec2 vUv;
    void main() {
      vec4 base = texture2D(baseTexture, vUv);
      vec4 bloom = texture2D(bloomTexture, vUv);
      gl_FragColor = base + bloom;
    }`
}), "baseTexture");
finalPass.needsSwap = true;

const finalComposer = new EffectComposer(renderer);
finalComposer.addPass(renderScene);
finalComposer.addPass(finalPass);

/* ---------------------------
   OBJECTS
---------------------------- */
const photoGroup = new THREE.Group();
scene.add(photoGroup);

/* ========== PARTICLE TREE (shader points) ========== */
function makeTreeBasePositions(count){
  const base = new Float32Array(count * 3);
  const yNorm = new Float32Array(count);
  const radial = new Float32Array(count);
  const size = new Float32Array(count);

  for(let i=0;i<count;i++){
    const p = i / (count - 1);
    const y = (p * CONFIG.treeHeight) - (CONFIG.treeHeight / 2);
    const r = (1 - p) * CONFIG.treeRadius * (0.95 + Math.random()*0.25);

    const a = p * Math.PI * 28 + (Math.random()-0.5)*0.6;
    const x = Math.cos(a) * r + (Math.random()-0.5)*1.2;
    const z = Math.sin(a) * r + (Math.random()-0.5)*1.2;

    base[i*3+0] = x;
    base[i*3+1] = y + (Math.random()-0.5)*0.65;
    base[i*3+2] = z;

    yNorm[i] = p;
    radial[i] = Math.min(1.0, Math.hypot(x, z) / (CONFIG.treeRadius*1.15));
    size[i] = 2.0 + Math.random()*2.6;
  }
  return { base, yNorm, radial, size };
}

const treeData = makeTreeBasePositions(CONFIG.particleCount);
const treePos = treeData.base.slice(0);
const treeVel = new Float32Array(CONFIG.particleCount * 3);

const treeGeo = new THREE.BufferGeometry();
treeGeo.setAttribute("position", new THREE.BufferAttribute(treePos, 3));
treeGeo.setAttribute("aY", new THREE.BufferAttribute(treeData.yNorm, 1));
treeGeo.setAttribute("aR", new THREE.BufferAttribute(treeData.radial, 1));
treeGeo.setAttribute("aSize", new THREE.BufferAttribute(treeData.size, 1));

function triggerScatterExplosion(){
  const posAttr = treeGeo.getAttribute("position");
  const arr = posAttr.array;
  for(let i=0;i<CONFIG.particleCount;i++){
    const idx = i*3;
    const x = arr[idx+0];
    const y = arr[idx+1];
    const z = arr[idx+2];
    const len = Math.sqrt(x*x + y*y + z*z) + 0.0001;
    const dirx = x/len, diry = y/len, dirz = z/len;

    const swirl = 0.8 + Math.random()*0.8;
    const sx = -dirz * swirl;
    const sz =  dirx * swirl;

    const speed = 1.2 + Math.random()*1.6;

    treeVel[idx+0] = dirx * speed + sx*0.4;
    treeVel[idx+1] = diry * speed * 0.6;
    treeVel[idx+2] = dirz * speed + sz*0.4;
  }

  const glowArr = glowGeo.getAttribute("position").array;
  for(let i=0;i<CONFIG.glowCount;i++){
    const idx = i*3;
    const x = glowArr[idx+0];
    const y = glowArr[idx+1];
    const z = glowArr[idx+2];
    const len = Math.sqrt(x*x + y*y + z*z) + 0.0001;
    const dirx = x/len, diry = y/len, dirz = z/len;
    const swirl = 0.8 + Math.random()*1.0;
    const sx = -dirz * swirl;
    const sz =  dirx * swirl;
    const speed = 1.0 + Math.random()*1.4;
    glowVel[idx+0] = dirx * speed + sx*0.45;
    glowVel[idx+1] = diry * speed * 0.55;
    glowVel[idx+2] = dirz * speed + sz*0.45;
  }

  for(let i=0;i<CONFIG.candyCount;i++){
    const curr = candyCurr[i];
    const len = curr.length() + 0.0001;
    const dir = curr.clone().divideScalar(len);
    const swirl = 0.9 + Math.random()*1.1;
    const sx = -dir.z * swirl;
    const sz =  dir.x * swirl;
    const speed = 1.4 + Math.random()*1.2;
    candyVel[i].set(
      dir.x * speed + sx*0.5,
      dir.y * speed * 0.7,
      dir.z * speed + sz*0.5
    );
  }
}

function calmToTree(){
  for(let i=0;i<treeVel.length;i++) treeVel[i]=0;
  for(let i=0;i<glowVel.length;i++) glowVel[i]=0;
  for(let i=0;i<candyVel.length;i++) candyVel[i].set(0,0,0);
}

const treeMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uTime: { value: 0 },
    uFade: { value: 1.0 }
  },
  vertexShader: `
    uniform float uTime;
    attribute float aY;
    attribute float aR;
    attribute float aSize;
    varying float vY;
    varying float vR;

    void main(){
      vY = aY;
      vR = aR;

      vec3 p = position;

      float sway = 0.08 + (1.0 - aY) * 0.12;
      p.x += sin(uTime + p.y * 0.35) * sway;
      p.z += cos(uTime + p.y * 0.35) * sway;

      vec4 mv = modelViewMatrix * vec4(p, 1.0);
      float dist = -mv.z;

      gl_PointSize = aSize * (280.0 / dist);
      gl_Position = projectionMatrix * mv;
    }
  `,
  fragmentShader: `
    varying float vY;
    varying float vR;
    uniform float uFade;

    float hash(vec2 p){
      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
    }

    void main(){
      vec2 uv = gl_PointCoord - 0.5;
      float d = length(uv);

      float soft = smoothstep(0.52, 0.10, d);

      /* Gaussian brightness: higher near the center */
      float g = exp(-vR * vR * 3.4);

      vec3 emerald = vec3(0.00, 0.62, 0.40);
      vec3 champ = vec3(1.00, 0.86, 0.58);
      float t = smoothstep(0.10, 0.95, vY);
      vec3 col = mix(emerald, champ, t);

      float tw = 0.85 + 0.25 * hash(gl_FragCoord.xy * 0.02);

      /* Cap tree brightness to avoid additive+bloom blowout */
      float baseAlpha = soft * g;
      float heightBoost = mix(0.35, 0.75, t);
      float alpha = clamp(baseAlpha * heightBoost * tw, 0.0, 0.45);
      col *= 0.85 * uFade;
      alpha *= uFade;
      if(alpha < 0.02) discard;

      gl_FragColor = vec4(col, alpha);
    }
  `
});

const treePoints = new THREE.Points(treeGeo, treeMat);
treePoints.layers.set(ENTIRE_SCENE);
scene.add(treePoints);

/* ========== GLOW LIGHTS (bloom points) ========== */
function makeGlowPositions(count){
  const pos = new Float32Array(count * 3);
  const size = new Float32Array(count);
  const hue = new Float32Array(count);

  for(let i=0;i<count;i++){
    const p = i / (count - 1);
    const y = (p * CONFIG.treeHeight) - (CONFIG.treeHeight / 2);
    const r = (1 - p) * CONFIG.treeRadius * (0.85 + Math.random()*0.30);
    const a = p * Math.PI * 20 + Math.random()*1.2;

    pos[i*3+0] = Math.cos(a) * r + (Math.random()-0.5)*2.0;
    pos[i*3+1] = y + (Math.random()-0.5)*1.4;
    pos[i*3+2] = Math.sin(a) * r + (Math.random()-0.5)*2.0;

    size[i] = 3.0 + Math.random()*5.5;

    const rnd = Math.random();
    hue[i] = rnd < 0.08 ? 1.0 : (rnd < 0.45 ? 0.55 : 0.25);
  }
  return { pos, size, hue };
}

const glowData = makeGlowPositions(CONFIG.glowCount);
const glowBase = glowData.pos.slice(0);
const glowPos = glowData.pos.slice(0);
const glowVel = new Float32Array(CONFIG.glowCount * 3);
const glowGeo = new THREE.BufferGeometry();
glowGeo.setAttribute("position", new THREE.BufferAttribute(glowPos, 3));
glowGeo.setAttribute("aSize", new THREE.BufferAttribute(glowData.size, 1));
glowGeo.setAttribute("aHue", new THREE.BufferAttribute(glowData.hue, 1));

const glowMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uTime: { value: 0 },
    uFade: { value: 1.0 }
  },
  vertexShader: `
    uniform float uTime;
    attribute float aSize;
    attribute float aHue;
    varying float vHue;

    void main(){
      vHue = aHue;
      vec3 p = position;

      p.x += sin(uTime*1.2 + p.y*0.25) * 0.05;
      p.z += cos(uTime*1.2 + p.y*0.25) * 0.05;

      vec4 mv = modelViewMatrix * vec4(p, 1.0);
      float dist = -mv.z;
      gl_PointSize = aSize * (320.0 / dist);
      gl_Position = projectionMatrix * mv;
    }
  `,
  fragmentShader: `
    varying float vHue;
    uniform float uFade;

    void main(){
      vec2 uv = gl_PointCoord - 0.5;
      float d = length(uv);
      float core = smoothstep(0.40, 0.00, d);
      float halo = smoothstep(0.75, 0.10, d);

      vec3 gold = vec3(1.0, 0.82, 0.28);
      vec3 warmWhite = vec3(1.0, 0.95, 0.80);
      vec3 red = vec3(1.0, 0.22, 0.22);

      vec3 col = mix(gold, warmWhite, step(0.40, vHue));
      col = mix(col, red, step(0.90, vHue));

      /* Fade edges to reduce large blurred squares */
      float alpha = core * 0.75 + halo * 0.12;
      col *= uFade;
      alpha *= uFade;
      if(alpha < 0.02) discard;

      gl_FragColor = vec4(col, alpha);
    }
  `
});

const glowPoints = new THREE.Points(glowGeo, glowMat);
glowPoints.layers.set(BLOOM_SCENE);
scene.add(glowPoints);

/* ========== TOP STAR (bloom) ========== */
const starTop = new THREE.Mesh(
  new THREE.IcosahedronGeometry(1.35, 1),
  new THREE.MeshStandardMaterial({
    color: 0xffd700,
    roughness: 0.20,
    metalness: 0.92,
    emissive: 0xffd700,
    emissiveIntensity: 1.25
  })
);
starTop.position.set(0, CONFIG.treeHeight/2 + 2.2, 0);
starTop.layers.enable(BLOOM_SCENE);
scene.add(starTop);

/* ========== CANDIES ========== */
const candyGeo = new THREE.SphereGeometry(0.35, 10, 10);
const candyMat = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  roughness: 0.35,
  metalness: 0.35,
  emissive: 0x2a0a0a,
  emissiveIntensity: 0.25
});
const candies = new THREE.InstancedMesh(candyGeo, candyMat, CONFIG.candyCount);
candies.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
candies.layers.set(ENTIRE_SCENE);
scene.add(candies);

const dummy = new THREE.Object3D();
const candyTargets = [];
const candyChaos = [];
const candyCurr = [];
const candyVel = [];
{
  const col = new THREE.Color();
  for(let i=0;i<CONFIG.candyCount;i++){
    const p = i/CONFIG.candyCount;
    const a = p*Math.PI*16;
    const r = (1-p)*CONFIG.treeRadius*1.0;

    const pos = new THREE.Vector3(
      Math.cos(a)*r + (Math.random()-0.5)*1.1,
      p*CONFIG.treeHeight - CONFIG.treeHeight/2 + (Math.random()-0.5)*5.0,
      Math.sin(a)*r + (Math.random()-0.5)*1.1
    );
  candyTargets.push(pos);

  const chaos = new THREE.Vector3(
    (Math.random()-0.5)*90,
    (Math.random()-0.5)*90,
    (Math.random()-0.5)*90
  );
  candyChaos.push(chaos);
  candyCurr.push(chaos.clone());
  candyVel.push(new THREE.Vector3());

    col.setHex(i%2===0 ? 0xff2a2a : 0xffffff);
    candies.setColorAt(i, col);
  }
  candies.instanceColor.needsUpdate = true;
}

/* ========== BACKGROUND STARS (always-on ambience) ========== */
const bgStarCount = 900;
const bgStarGeo = new THREE.BufferGeometry();
const bgStarPos = new Float32Array(bgStarCount * 3);
const bgStarCol = new Float32Array(bgStarCount * 3);
{
  const c = new THREE.Color();
  for(let i=0;i<bgStarCount;i++){
    const r = 140 + Math.random()*180;      // 半径：围绕场景较远处
    const theta = Math.random() * Math.PI * 2;
    const phi = (Math.random()*0.6 - 0.3) * Math.PI; // 稍微有一点上下分布

    const x = Math.cos(theta) * Math.cos(phi) * r;
    const y = Math.sin(phi) * r * 0.4;
    const z = Math.sin(theta) * Math.cos(phi) * r;

    bgStarPos[i*3+0] = x;
    bgStarPos[i*3+1] = y;
    bgStarPos[i*3+2] = z;

    // 以暖白、淡金为主，整体偏温柔
    const rnd = Math.random();
    if(rnd < 0.35)      c.set(0xfff4d5); // 淡金
    else if(rnd < 0.8)  c.set(0xfffbe0); // 暖白
    else                c.set(0xffe0b0); // 稍深一点的暖黄

    bgStarCol[i*3+0] = c.r;
    bgStarCol[i*3+1] = c.g;
    bgStarCol[i*3+2] = c.b;
  }
}
bgStarGeo.setAttribute("position", new THREE.BufferAttribute(bgStarPos, 3));
bgStarGeo.setAttribute("color",    new THREE.BufferAttribute(bgStarCol, 3));

const bgStarMat = new THREE.PointsMaterial({
  size: 0.9,
  vertexColors: true,
  transparent: true,
  opacity: 0.55,
  depthWrite: false,
  blending: THREE.AdditiveBlending
});
const bgStars = new THREE.Points(bgStarGeo, bgStarMat);
bgStars.layers.set(ENTIRE_SCENE);
scene.add(bgStars);

/* ---------------------------
   APP STATE + HAND TURBULENCE
---------------------------- */
let APP_STATE = "TREE";
let cameraAngle = 0;
let prevHandX = 0.5;
let zoomPhotoIndex = -1;
let prevAppState = APP_STATE;
let lastExplosionTime = 0;

// 启动时自动加载的本地图片（相对 index.html 的路径，放在 ./img/ 文件夹下）
const INITIAL_PHOTO_PATHS = [
  // 当前 img 目录中的示例图片
  "img/1.jpg",
  "img/2.jpg",
  "img/3.jpg",
  "img/4.jpg",
  "img/5.jpg",
  "img/6.jpg",
  "img/7.jpg",
  "img/8.jpg",
  "img/9.jpg",
  "img/10.jpg",
  "img/11.jpg",
  "img/12.jpg"
];

const statusEl = document.getElementById("status");
const targetScaleZoom = new THREE.Vector3(1.0,1.0,1.0);
const targetScaleTree = new THREE.Vector3(0.65,0.65,0.65);
const targetScaleScatter = new THREE.Vector3(1.0,1.0,1.0);

const handWorld = new THREE.Vector3(0, 5, 0);
let handHasSignal = false;

/* ---------------------------
   PHOTO UPLOAD
---------------------------- */
function createPhoto(texture){
  const aspect = texture.image.width / texture.image.height;
  const w = 6.5;
  const h = w / aspect;

  // 照片本身：保持原始色彩，不再叠加暗角和大面积色块
  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(w, h),
    new THREE.MeshBasicMaterial({
      map: texture,
      toneMapped: false,
      transparent: true,
      opacity: 1.0,
      color: new THREE.Color(1.15, 1.10, 1.05) // 略微提亮并带一点暖色
    })
  );
  plane.material.depthTest = false;
  plane.material.depthWrite = false;
  plane.renderOrder = 900;
  plane.layers.set(ENTIRE_SCENE);

  // 细窄的玻璃质感边框
  const frame = new THREE.Mesh(
    new THREE.BoxGeometry(w+0.35, h+0.35, 0.12),
    new THREE.MeshPhysicalMaterial({
      color: 0xfff7d5,
      roughness: 0.45,
      metalness: 0.2,
      transmission: 0.6,
      thickness: 0.5,
      clearcoat: 1.0,
      clearcoatRoughness: 0.25,
      emissive: 0xfff2c0,
      emissiveIntensity: 0.18,
      transparent: true,
      opacity: 0.95
    })
  );
  frame.position.z = -0.08;
  frame.material.depthTest = false;
  frame.material.depthWrite = false;
  frame.renderOrder = 901;
  frame.layers.set(ENTIRE_SCENE);
  plane.add(frame);

  plane.position.set(
    (Math.random()-0.5)*50,
    (Math.random()-0.5)*40,
    (Math.random()-0.5)*50
  );

  plane.userData = {
    treePos: new THREE.Vector3(
      (Math.random()-0.5)*12,
      (Math.random()*20)-8,
      (Math.random()-0.5)*12
    ),
    scatterPos: plane.position.clone()
  };

  photoGroup.add(plane);
}

function loadInitialPhotos(){
  if(!INITIAL_PHOTO_PATHS || INITIAL_PHOTO_PATHS.length === 0) return;

  const loader = new THREE.TextureLoader();
  console.log("INITIAL_PHOTO_PATHS:", INITIAL_PHOTO_PATHS);
  INITIAL_PHOTO_PATHS.forEach((path)=>{
    loader.load(
      path,
      (tex)=>{
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        tex.minFilter = THREE.LinearMipmapLinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.needsUpdate = true;
        createPhoto(tex);
        console.log("Loaded initial photo:", path);
      },
      undefined,
      ()=>{
        console.warn("Failed to load initial photo:", path);
      }
    );
  });
}

document.getElementById("upload-input").addEventListener("change", (e)=>{
  const files = e.target.files;
  if(!files || files.length===0) return;

  for(const f of files){
    const url = URL.createObjectURL(f);
    const loader = new THREE.TextureLoader();
    loader.load(url, (tex)=>{
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.minFilter = THREE.LinearMipmapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.needsUpdate = true;
      createPhoto(tex);
    });
  }
});

// 手动控制按钮：在无法使用摄像头时也能体验
const btnTree    = document.getElementById("btn-tree");
const btnScatter = document.getElementById("btn-scatter");
const btnZoom    = document.getElementById("btn-zoom");

if(btnTree){
  btnTree.addEventListener("click", ()=>{
    APP_STATE = "TREE";
    zoomPhotoIndex = -1;
    calmToTree();
    statusEl.textContent = "TREE | make a fist to form the tree";
    statusEl.style.color = "#88ff88";
  });
}

if(btnScatter){
  btnScatter.addEventListener("click", ()=>{
    const last = APP_STATE;
    APP_STATE = "SCATTER";
    zoomPhotoIndex = -1;
    statusEl.textContent = "SCATTER | open hand, move left/right to orbit";
    statusEl.style.color = "#ffdf00";
    // 模拟从 TREE 进入 SCATTER 的一次爆炸
    if(last === "TREE"){
      triggerScatterExplosion();
    }
  });
}

if(btnZoom){
  btnZoom.addEventListener("click", ()=>{
    if(photoGroup.children.length === 0) return;
    APP_STATE = "ZOOM";
    zoomPhotoIndex = Math.floor(Math.random()*photoGroup.children.length);
    statusEl.textContent = "ZOOM | pinch to grab & zoom photo";
    statusEl.style.color = "#ff8888";
  });
}

// 页面加载完后，自动从 img/ 文件夹读取默认照片
window.addEventListener("load", loadInitialPhotos);

/* ---------------------------
   MediaPipe Hands + Preview
---------------------------- */
const videoEl = document.getElementById("video-input");
const handCanvas = document.getElementById("hand-canvas");
const hctx = handCanvas.getContext("2d");
const handDebug = document.getElementById("hand-debug");
const handPanelEl = document.getElementById("hand-panel");
const handToggleBtn = document.getElementById("hand-toggle");
let handPanelVisible = true;

if(handToggleBtn && handPanelEl){
  handToggleBtn.addEventListener("click", ()=>{
    handPanelVisible = !handPanelVisible;
    handPanelEl.style.display = handPanelVisible ? "" : "none";
    handToggleBtn.textContent = handPanelVisible ? "隐藏预览" : "显示预览";
  });
}

function drawHandPreview(results){
  const w = handCanvas.width, h = handCanvas.height;

  try{
    hctx.drawImage(videoEl, 0, 0, w, h);
    hctx.fillStyle = "rgba(0,0,0,0.35)";
    hctx.fillRect(0,0,w,h);
  }catch{
    hctx.clearRect(0,0,w,h);
    hctx.fillStyle="#000"; hctx.fillRect(0,0,w,h);
  }

  const lm = results.multiHandLandmarks?.[0];
  if(!lm) return;

  hctx.strokeStyle="rgba(255,223,0,0.95)";
  hctx.lineWidth=2;
  const chains=[[0,1,2,3,4],[0,5,6,7,8],[0,9,10,11,12],[0,13,14,15,16],[0,17,18,19,20]];
  for(const ch of chains){
    hctx.beginPath();
    ch.forEach((idx,i)=>{
      const p=lm[idx];
      const x=p.x*w, y=p.y*h;
      if(i===0) hctx.moveTo(x,y); else hctx.lineTo(x,y);
    });
    hctx.stroke();
  }
  for(const p of lm){
    hctx.beginPath();
    hctx.arc(p.x*w,p.y*h,3.6,0,Math.PI*2);
    hctx.fillStyle="rgba(255,90,90,0.95)";
    hctx.fill();
  }
}

function detectGesture(lm){
  const wrist = lm[0];
  const thumbTip = lm[4];
  const indexTip = lm[8];
  const pinkyTip = lm[20];

  let avg = 0;
  [8,12,16,20].forEach(i=>{
    avg += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y);
  });
  avg /= 4;

  const pinch = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
  const openDist = Math.hypot(indexTip.x - pinkyTip.x, indexTip.y - pinkyTip.y);

  // 适度放宽阈值：握拳更容易被识别，但仍与捏合 / 张开区分
  const isOtherFingersBent = avg > 0.08 && avg < 0.34;
  const isPinch = (pinch < 0.08) && (openDist > 0.12) && isOtherFingersBent;
  const isFist = (avg < 0.24) && (openDist < 0.18) && (pinch > 0.10);
  const isOpen = avg > 0.27 && openDist > 0.22;

  const handX = wrist.x;

  handWorld.set(
    (wrist.x - 0.5) * 28.0,
    (0.5 - wrist.y) * 20.0 + 6.0,
    0
  );
  handHasSignal = true;

  const lastState = APP_STATE;
  if(isPinch && photoGroup.children.length>0){
    if(APP_STATE!=="ZOOM"){
      APP_STATE="ZOOM";
      zoomPhotoIndex = Math.floor(Math.random()*photoGroup.children.length);
      statusEl.textContent="ZOOM | pinch to grab & zoom photo";
      statusEl.style.color="#ff8888";
    }
  }else if(APP_STATE==="ZOOM" && pinch>0.08){
    APP_STATE="SCATTER";
    zoomPhotoIndex=-1;
    statusEl.textContent="SCATTER | open hand, move left/right to orbit";
    statusEl.style.color="#ffdf00";
  }else if(isFist){
    APP_STATE="TREE";
    statusEl.textContent="TREE | make a fist to form the tree";
    statusEl.style.color="#88ff88";
    calmToTree();
  }else if(isOpen){
    if(APP_STATE!=="ZOOM"){
      APP_STATE="SCATTER";
      statusEl.textContent="SCATTER | open hand, move left/right to orbit";
      statusEl.style.color="#ffdf00";
      const deltaX = THREE.MathUtils.clamp(handX - prevHandX, -0.08, 0.08);
      cameraAngle += deltaX * 6.0;
    }
  }

  // 仅在从 TREE 切换到 SCATTER 时触发一次爆炸效果，
  // 避免从 ZOOM 返回 SCATTER 时背景轨迹被反复重置。
  if(lastState==="TREE" && APP_STATE==="SCATTER"){
    const now = performance.now();
    if(now - lastExplosionTime > 800){
      triggerScatterExplosion();
      lastExplosionTime = now;
    }
  }
  prevAppState = APP_STATE;
  prevHandX = handX;
  handDebug.textContent = `HAND:${APP_STATE} | avg:${avg.toFixed(3)} pinch:${pinch.toFixed(3)}`;
}

function setupMediaPipe(){
  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    const loader = document.getElementById("loader");
    // 不再用大面积遮罩文案卡住页面，只在状态栏提示
    loader.style.opacity = 0;
    setTimeout(()=>loader.remove(), 800);
    statusEl.textContent = "当前环境无法访问摄像头，可直接使用下方按钮和上传照片体验圣诞树。";
    statusEl.style.color = "#ffdf00";
    return;
  }

  const hands = new Hands({
    locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });

  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.6
  });

  hands.onResults((results)=>{
    drawHandPreview(results);

    if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
      detectGesture(results.multiHandLandmarks[0]);
    }else{
      handHasSignal = false;
      handDebug.textContent = "HAND: NOT DETECTED";
    }
  });

  const cam = new Camera(videoEl, {
    onFrame: async ()=>{ await hands.send({image: videoEl}); },
    width: 640,
    height: 480,
    facingMode: "user"
  });

  cam.start().then(()=>{
    const loader=document.getElementById("loader");
    loader.style.opacity=0;
    setTimeout(()=>loader.remove(), 900);
  }).catch((err)=>{
    console.error("Camera start failed:", err);
    const loader=document.getElementById("loader");
    loader.style.opacity = 0;
    setTimeout(()=>loader.remove(), 800);
    statusEl.textContent = "无法启动摄像头，你仍可用下方按钮控制圣诞树并上传照片。";
    statusEl.style.color = "#ffdf00";
  });
}

function isMobile(){
  return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
}

if(isMobile()){
  const loader = document.getElementById("loader");
  loader.innerHTML = `<div style="text-align:center;max-width:520px;line-height:1.6;cursor:pointer">
    <div style="font-size:18px;margin-bottom:10px;color:#ffdf00">点此启用摄像头 & 手势识别</div>
    <div style="color:#bbb;letter-spacing:1px">已通过 HTTPS 打开，可安全使用手机前置摄像头。</div>
    <div style="margin-top:14px;color:#ffdf00;opacity:.9">如果不需要，可直接上传照片体验粒子圣诞树。</div>
  </div>`;
  loader.addEventListener("click", ()=>{
    loader.textContent = "INITIALIZING VISION & MAGIC...";
    setupMediaPipe();
  }, { once:true });
}else{
  setupMediaPipe();
}

/* ---------------------------
   Updates
---------------------------- */
function updateCandies(time){
  const isScatterLike = (APP_STATE==="SCATTER" || APP_STATE==="ZOOM");
  for(let i=0;i<CONFIG.candyCount;i++){
    const target = (APP_STATE==="TREE") ? candyTargets[i] : candyChaos[i];
    const curr = candyCurr[i];
    const vel = candyVel[i];
    const dir = target.clone().sub(curr).multiplyScalar(0.06);
    vel.add(dir);
    const damp = isScatterLike ? 0.95 : 0.9;
    vel.multiplyScalar(damp);
    curr.add(vel);

    dummy.position.copy(curr);

    if(APP_STATE==="TREE"){
      dummy.scale.set(1,1,1);
      dummy.rotation.y = time*0.15 + i*0.09;
      dummy.rotation.x = time*0.10;
      dummy.rotation.z = time*0.07;
    }else{
      dummy.scale.set(1,1,1);
      dummy.rotation.y = time*0.35 + i*0.06;
      dummy.rotation.x = time*0.15;
      dummy.rotation.z = 0;
    }

    dummy.updateMatrix();
    candies.setMatrixAt(i, dummy.matrix);
  }
  candies.instanceMatrix.needsUpdate = true;
}

function updateTreeParticles(time){
  const posAttr = treeGeo.getAttribute("position");
  const arr = posAttr.array;
  const isScatterLike = (APP_STATE==="SCATTER" || APP_STATE==="ZOOM");

  for(let i=0;i<CONFIG.particleCount;i++){
    const idx = i*3;

    const bx = treeData.base[idx+0];
    const by = treeData.base[idx+1];
    const bz = treeData.base[idx+2];

    let tx=bx, ty=by, tz=bz;

    if(isScatterLike){
      const push = 1.0 + 1.35 * Math.sin((i*0.013) + time*0.35);
      tx = bx * push * 2.2;
      ty = by + Math.sin(time*0.8 + i*0.01) * 0.6;
      tz = bz * push * 2.2;
    }

    const cx = arr[idx+0], cy = arr[idx+1], cz = arr[idx+2];
    const vx = treeVel[idx+0], vy = treeVel[idx+1], vz = treeVel[idx+2];

    let nvx = vx + (tx - cx) * 0.010;
    let nvy = vy + (ty - cy) * 0.010;
    let nvz = vz + (tz - cz) * 0.010;

    if(handHasSignal && APP_STATE!=="ZOOM"){
      const dx = cx - handWorld.x;
      const dy = cy - handWorld.y;
      const dz = cz - handWorld.z;
      const d = Math.sqrt(dx*dx + dy*dy + dz*dz);

      if(d < CONFIG.turbulenceRadius){
        const s = (1.0 - d / CONFIG.turbulenceRadius) * CONFIG.turbulenceStrength;

        nvx += (-dz) * s * 0.012;
        nvz += ( dx) * s * 0.012;
        nvy += Math.sin(time*2.1 + i*0.02) * s * 0.006;
      }
    }

    nvx *= isScatterLike ? 0.96 : 0.92;
    nvy *= isScatterLike ? 0.96 : 0.92;
    nvz *= isScatterLike ? 0.96 : 0.92;

    arr[idx+0] = cx + nvx;
    arr[idx+1] = cy + nvy;
    arr[idx+2] = cz + nvz;

    treeVel[idx+0] = nvx;
    treeVel[idx+1] = nvy;
    treeVel[idx+2] = nvz;
  }

  posAttr.needsUpdate = true;

  treeMat.uniforms.uTime.value = time;
  glowMat.uniforms.uTime.value = time;
}

function updateGlowPositions(time){
  const arr = glowGeo.getAttribute("position").array;
  const isScatterLike = (APP_STATE==="SCATTER" || APP_STATE==="ZOOM");
  for(let i=0;i<CONFIG.glowCount;i++){
    const idx = i*3;
    const bx = glowBase[idx+0];
    const by = glowBase[idx+1];
    const bz = glowBase[idx+2];

    let tx = bx, ty = by, tz = bz;
    if(isScatterLike){
      const push = 1.0 + 1.15 * Math.sin((i*0.021) + time*0.28);
      tx = bx * push * 2.0;
      ty = by + Math.sin(time*0.9 + i*0.015) * 0.5;
      tz = bz * push * 2.0;
    }

    const cx = arr[idx+0], cy = arr[idx+1], cz = arr[idx+2];
    const vx = glowVel[idx+0], vy = glowVel[idx+1], vz = glowVel[idx+2];

    let nvx = vx + (tx - cx) * 0.012;
    let nvy = vy + (ty - cy) * 0.012;
    let nvz = vz + (tz - cz) * 0.012;

    const damp = isScatterLike ? 0.965 : 0.92;
    nvx *= damp; nvy *= damp; nvz *= damp;

    arr[idx+0] = cx + nvx;
    arr[idx+1] = cy + nvy;
    arr[idx+2] = cz + nvz;

    glowVel[idx+0] = nvx;
    glowVel[idx+1] = nvy;
    glowVel[idx+2] = nvz;
  }
  glowGeo.attributes.position.needsUpdate = true;
}

/* ---------------------------
   ANIMATE
---------------------------- */
function animate(){
  requestAnimationFrame(animate);
  const t = Date.now()*0.001;

  const radius = 48;
  if(APP_STATE==="SCATTER"){
    camera.position.x = radius * Math.sin(t*0.12 + cameraAngle);
    camera.position.z = radius * Math.cos(t*0.12 + cameraAngle);
  }else{
    camera.position.x = radius * Math.sin(t*0.07);
    camera.position.z = radius * Math.cos(t*0.07);
  }
  camera.lookAt(0, 5, 0);

  updateTreeParticles(t);
  updateCandies(t);
  updateGlowPositions(t);
  // 背景星点缓慢自转，比圣诞树更慢
  bgStars.rotation.y += 0.0005;

  starTop.scale.setScalar(1.0 + 0.06*Math.sin(t*2.0));
  starTop.rotation.y = t * 0.6;
  const starTargetIntensity = (APP_STATE === "ZOOM") ? 0.15 : 1.25;
  starTop.material.emissiveIntensity += (starTargetIntensity - starTop.material.emissiveIntensity) * 0.12;

  photoGroup.children.forEach((mesh, idx)=>{
    let targetPos, targetScale;

    if(APP_STATE==="ZOOM" && idx===zoomPhotoIndex){
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      // 放大时稍远一点，让背景树有空间露出
      targetPos = camera.position.clone().add(dir.multiplyScalar(20));
      targetScale = targetScaleZoom;
      mesh.lookAt(camera.position);
    }else if(APP_STATE==="TREE"){
      targetPos = mesh.userData.treePos;
      targetScale = targetScaleTree;
      mesh.rotation.y = t*0.25;
      mesh.rotation.x = Math.sin(t*0.6 + idx)*0.08;
    }else{
      targetPos = mesh.userData.scatterPos;
      targetScale = targetScaleScatter;
      mesh.lookAt(camera.position);
    }

    const photoLerp = (APP_STATE==="ZOOM") ? CONFIG.photoLerpZoom : CONFIG.photoLerpNormal;
    mesh.position.lerp(targetPos, photoLerp);
    mesh.scale.lerp(targetScale, photoLerp);

    // 根据状态，为当前放大的照片叠加暖黄色灯光氛围
    // 这里原本有暖黄色覆盖层与背后 glow，已去掉以保持照片原始亮度
  });

  const fadeTreeTarget = (APP_STATE === "ZOOM") ? 0.85 : 1.0;
  const fadeGlowTarget = (APP_STATE === "ZOOM") ? 0.5 : 1.0;
  treeMat.uniforms.uFade.value += (fadeTreeTarget - treeMat.uniforms.uFade.value) * 0.12;
  glowMat.uniforms.uFade.value += (fadeGlowTarget - glowMat.uniforms.uFade.value) * 0.12;

  const targetExposure = (APP_STATE === "ZOOM") ? 0.75 : CONFIG.exposure;
  renderer.toneMappingExposure += (targetExposure - renderer.toneMappingExposure) * 0.06;

  // 放大时整体 Bloom 显著减弱，避免树光盖住照片
  const targetBloom = (APP_STATE === "ZOOM") ? 0.12 : CONFIG.bloomStrength;
  bloomPass.strength += (targetBloom - bloomPass.strength) * 0.12;
  const targetBloomRadius = (APP_STATE === "ZOOM") ? 0.2 : CONFIG.bloomRadius;
  bloomPass.radius += (targetBloomRadius - bloomPass.radius) * 0.12;
  const targetBloomThreshold = (APP_STATE === "ZOOM") ? 0.8 : CONFIG.bloomThreshold;
  bloomPass.threshold += (targetBloomThreshold - bloomPass.threshold) * 0.12;

  camera.layers.set(BLOOM_SCENE);
  bloomComposer.render();
  camera.layers.set(ENTIRE_SCENE);
  finalComposer.render();
}
animate();

/* ---------------------------
   Resize
---------------------------- */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  bloomComposer.setSize(innerWidth, innerHeight);
  finalComposer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
